---
title: 'HTTP'
date: '2024-03-20'
---

## 简介

**HTTP**协议是**超文本传输协议(Hyper Text Transfer Protocol)** 的缩写，是从Web服务器传输超文本标记语言到本地浏览器传送协议，它是基于传输层协议TCP/IP通信协议来传送数据的。

## 特点

1. 无状态：也就是不保存**通信过程中的上下文信息**，每次HTTP请求都是独立、无关、默认不保留状态信息。
2. 灵活：允许传输文本、图片、视频等任意数据，传输的类型由Content-Type加以标记。
3. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
4. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

## 缺点
1. 明文传输：通信使用明文（不加密），内容可能会被窃听
2. 不验证通信方身份，可能遭遇伪装
3. 无法证明报文的完整性，所以有可能被篡改
4. 无状态：对于需要长连接，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。如果应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

## HTTP报文结构

> 用于HTTP协议交互的信息叫做HTTP报文

HTTP报文大致分为**报文头部**和**报文主体**两部分组成
 - 报文首部：服务端或客户端需处理的请求或响应的内容及属性
 - 报文主体：应被发送数据

具体而言：

```js
1. 起始行 + 头部 + 空行 + 实体
```
由于 http 请求报文和响应报文是有一定区别，因此我们分开介绍。

### 起始行

请求报文
> GET /home HTTP/1.1
> 方法 + 路径 + http版本

响应报文
> HTTP/1.1 200 OK
> http版本 + 状态码 + 原因

### 头部
请求报文
- 请求行（request line）
- 请求头部（header）
- 空行
- 请求数据
> GET /hello.txt HTTP/1.1  起始行
> User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
> Host: www.example.com
> Accept-Language: en, mi

头部以键值对的形式出现、字段名：值

响应报文
- 状态行
- 消息报文
- 空行
- 响应体
![响应报文](https://raw.githubusercontent.com/Wild-bit/myBlog/main/img/Bowser/HTTPReq.png)

### 空行
很重要，用来区分开头部和实体。

问: 如果说在头部中间故意加一个空行会怎么样？

那么空行后的内容全部被视为实体。

### 实体
就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。

## 版本更替
### HTTP1.1
#### 特点
- **Cookie**：引入Cookie机制和安全机制
- **keep-alive长连接**：头信息Connection参数默认开启（HTTP1.0默认关闭）
**Connection:keep-alive**实现持久连接，使得在头部传输**Connection：close**能对当前的TCP连接进行复用，减少了建立TCP和断开TCP所产生的延迟和消耗。
  - 浏览器对同一个域名，默认允许同时建立6个TCP持久连接
- **局部资源请求**：在请求头上引入range头域，只允许请求资源的一部分，即返回码是206，能够支持HTTP/1.0无法支持动态内容返回，引入**分块传输编码**（Chunk transfer）的机制解决该问题，服务器将数据切割成若干个任意大小的数据块，每个数据块发送时带上数据块的大小。
- **缓存**：http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- 新增host字段：用来指定服务器的域名。首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。相同IP地址下部署运行这多个域名，那么服务器就无法理解对应是哪个主机，因此需要用Host字段明确指定是哪个主机名。

#### 缺陷
- **队头阻塞**仍然未解决（**一个TCP连接同时只能处理一个请求，在当前请求还没结束前，其他请求为阻塞状态**）
- TCP的慢启动导致的性能问题，小文件也要花费比较长的时间（**慢启动：每次TCP接收窗口收到确认时都会增长**）
- 多条TCP链接之间竞争带宽，没有优先级

### HTTP2.0

#### 特点
- **二进制分帧**：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
- **多路复用**：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了队头堵塞的问题。
- **头信息压缩**： 双端共同维护一张首部表，从而无需每次更新都携带首部
- **可设置优先级**：服务器会优先处理优先级高的（解决HTTP/1.1出现的多条TCP争抢带宽的缺陷）
- **服务端推送（不再是只有客户端能够主动发送**）：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

**问题：多路复用如何解决HTTP/1.1的队头阻塞？**

答：HTTP/2 是一个二进制协议，头信息和数据体都是二进制，并且统称为"帧"，Headers帧存放头部字段，Data帧存放请求体数据，分帧之后，服务端看到的就不是一个完整的报文信息，而是一堆乱序的二进制帧，这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。

通信双方都可以给对方发送二进制帧，这种二进制帧的**双向传输的序列**，也叫做**流(Stream)**。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。

**那最后如何来处理这些乱序的数据帧呢？**

所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。


